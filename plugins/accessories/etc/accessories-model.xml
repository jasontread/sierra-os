<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE entity-model PUBLIC "-//SIERRA//DTD ENTITY MODEL//EN" 
  "http://sierra-php.googlecode.com/svn/trunk/lib/model/entity-model.dtd">
<entity-model>
  
  <entity key="AddressBook" primary-key="addressBookId" render-append="getAllGroupsHash getUserContact" render-exclude="contacts groups subscriptions">
    <ajax-service key="manageAddressBook" update="1">
      <ajax-constraint-group key="setUid">
        <ajax-constraint attr="uid" auto-set="1" value="user_uid" value-type="global" />
      </ajax-constraint-group>
    </ajax-service>
    <aop>
      <aspect key="validateUser" pointcut="vo.validate" when="after"><![CDATA[
      // make sure user has permission to modify this address book
      global $user;
      if (!$this->validateErrors && $this->isDirty() && $this->getUid() && (!$user || ($user->getUid() != $this->getUid() && !$user->isChild($this->getUid())))) {
        $this->validateErrors[] = $rb->getString('AddressBook.error.noPermission');
      }
      ]]></aspect>
      <aspect key="validateSubscriptions" pointcut="vo.validate" when="after"><![CDATA[
      // make sure user has permission to add a subscription
      if (!$this->validateErrors && $this->isDirty('subscriptions') && ($subscriptions =& $this->getAddedVals('subscriptions'))) {
        $keys = array_keys($subscriptions);
        foreach($keys as $key) {
          if ($this->equals($subscriptions[$key]->getAddressBook())) {
            $this->validateErrors['subscriptions'] = $rb->getString('AddressBook.error.cannotSubscribeToOwnGroup');
          }
          else if (!$subscriptions[$key]->canSubscribe($this->getUid())) {
            $this->validateErrors['subscriptions'] = $rb->getString('AddressBook.error.noPermissionToSubscribe');
          }
        }
      }
      ]]></aspect>
      
      <introduction key="getAllContactIds" class="vo" type="method" value="getAllContactIds()"><![CDATA[
      // returns the ids of all of the contacts in this address book
      $db =& SRA_Controller::getAppDb();
      $allContactIds = array();
      
      // contacts
      $results =& $db->fetch('SELECT contact_id FROM contact WHERE address_book_id=' . $this->getPrimaryKey());
      while($row =& $results->next()) {
        $allContactIds[$row[0]] = TRUE;
      }
      
      // groups
      if ($groups =& $this->getGroups()) {
        $keys = array_keys($groups);
        foreach($keys as $key) {
          if ($contactIds =& $groups[$key]->getContactIds()) {
            $ckeys = array_keys($contactIds);
            foreach($ckeys as $ckey) {
              $allContactIds[$contactIds[$ckey]] = TRUE;
            }
          }
        }
      }
      
      // subscriptions
      if ($groups =& $this->getSubscriptions()) {
        $keys = array_keys($groups);
        foreach($keys as $key) {
          if ($contactIds =& $groups[$key]->getContactIds()) {
            $ckeys = array_keys($contactIds);
            foreach($ckeys as $ckey) {
              $allContactIds[$contactIds[$ckey]] = TRUE;
            }
          }
        }
      }
      
      return array_keys($allContactIds);
      ]]></introduction>
      <introduction key="getAllContacts" class="vo" type="method" value="&amp;getAllContacts()"><![CDATA[
      // returns all of the ContactVO records associated with this address book
      // indexed by contact id (no duplicates)
      $allContacts = array();
      
      // contacts
      if ($contacts =& $this->getContacts()) {
        $keys = array_keys($contacts);
        foreach($keys as $key) {
          $allContacts[$contacts[$key]->getContactId()] =& $contacts[$key];
        }
      }
      
      // groups
      if ($groups =& $this->getGroups()) {
        $keys = array_keys($groups);
        foreach($keys as $key) {
          if ($contacts =& $groups[$key]->getContacts()) {
            $ckeys = array_keys($contacts);
            foreach($ckeys as $ckey) {
              $allContacts[$contacts[$ckey]->getContactId()] =& $contacts[$ckey];
            }
          }
        }
      }
      
      // subscriptions
      if ($groups =& $this->getSubscriptions()) {
        $keys = array_keys($groups);
        foreach($keys as $key) {
          if ($contacts =& $groups[$key]->getContacts()) {
            $ckeys = array_keys($contacts);
            foreach($ckeys as $ckey) {
              $allContacts[$contacts[$ckey]->getContactId()] =& $contacts[$ckey];
            }
          }
        }
      }
      
      return $allContacts;
      ]]></introduction>
      <introduction key="getAllGroupIds" class="vo" type="method" value="getAllGroupIds()"><![CDATA[
      // returns the ids of all of the groups associated with this address book 
      // (groups + subscriptions)
      $allGroups = $this->getAllGroups();
      return array_keys($allGroups);
      ]]></introduction>
      <introduction key="getAllGroups" class="vo" type="method" value="&amp;getAllGroups()"><![CDATA[
      // returns all of the groups associated with this address book (groups + 
      // subscriptions). the returned array will be indexed by groupId
      if (!isset($this->_allGroups)) {
        $this->_allGroups = array();
        if ($groups =& $this->getGroups()) {
          $keys = array_keys($groups);
          foreach($keys as $key) {
            $this->_allGroups[$groups[$key]->getGroupId()] =& $groups[$key];
          }
        }
        if ($groups =& $this->getSubscriptions()) {
          $keys = array_keys($groups);
          foreach($keys as $key) {
            $this->_allGroups[$groups[$key]->getGroupId()] =& $groups[$key];
          }
        }
      }
      return $this->_allGroups;
      ]]></introduction>
      <introduction key="getAllGroupsHash" class="vo" type="method" value="&amp;getAllGroupsHash()"><![CDATA[
      // returns all of the groups associated with this address book as a hash
      // indexed by groupId and sorted by group name where each value in the 
      // hash contains the following keys: 
      //   groupId, gid, name, isSubscription, isReadOnly
      if (!isset($this->_allGroupsHash)) {
        $this->_allGroupsHash = array();
        if ($groups =& $this->getGroups()) {
          $keys = array_keys($groups);
          foreach($keys as $key) {
            $gid = $groups[$key]->getGroupId();
            $this->_allGroupsHash[$gid] = array('groupId' => $gid, 'gid' => $groups[$key]->getGid(), 'name' => $groups[$key]->getName(), 'isSubscription' => FALSE, 'isReadOnly' => FALSE);
          }
        }
        if ($groups =& $this->getSubscriptions()) {
          $keys = array_keys($groups);
          foreach($keys as $key) {
            $gid = $groups[$key]->getGroupId();
            $this->_allGroupsHash[$gid] = array('groupId' => $gid, 'gid' => $groups[$key]->getGid(), 'name' => $groups[$key]->getName(), 'isSubscription' => TRUE, 'isReadOnly' => $groups[$key]->isPublicReadOnly());
          }
        }
        $this->_allGroupsHash =& SRA_Util::sortObjects($this->_allGroupsHash, 'name', TRUE, FALSE);
      }
      return $this->_allGroupsHash;
      ]]></introduction>
      <introduction key="getContact" class="vo" type="method" value="&amp;getContact($contactId)"><![CDATA[
      // returns the contact specified by $contactId if it is associated with 
      // this address book. this method search groups and subscriptions also
      if ($contactId) {
        // contacts
        if ($this->hasBeenSet('contacts')) {
          if ($this->_contacts) {
            $keys = array_keys($this->_contacts);
            foreach($keys as $key) {
              if ($this->_contacts[$key]->getContactId() == $contactId) { return $this->_contacts[$key]; }
            }
          }
        }
        else if (SRA_Database::getQueryValue(SRA_Controller::getAppDb(), 'SELECT contact_id FROM contact WHERE contact_id=' . $contactId . ' AND address_book_id=' . $this->getPrimaryKey())) {
          $dao =& SRA_DaoFactory::getDao('Contact');
          return $dao->findByPk($contactId);
        }
        
        // groups
        if ($groups =& $this->getGroups()) {
          $keys = array_keys($groups);
          foreach($keys as $key) {
            if ($contact =& $groups[$key]->getContact($contactId)) { return $contact; }
          }
        }
        
        // subscriptions
        if ($groups =& $this->getSubscriptions()) {
          $keys = array_keys($groups);
          foreach($keys as $key) {
            if ($contact =& $groups[$key]->getContact($contactId)) { return $contact; }
          }
        }
      }
      
      $nl = NULL;
      return $nl;
      ]]></introduction>
      <introduction key="getGroup" class="vo" type="method" value="&amp;getGroup($groupId)"><![CDATA[
      // returns the ContactGroup for the group specified by $groupId
      
      // groups
      if ($groupId && ($groups =& $this->getGroups())) {
        $keys = array_keys($groups);
        foreach($keys as $key) {
          if ($groups[$key]->getGroupId() == $groupId) { return $groups[$key]; }
        }
      }
      
      // subscriptions
      if ($groupId && ($groups =& $this->getSubscriptions())) {
        $keys = array_keys($groups);
        foreach($keys as $key) {
          if ($groups[$key]->getGroupId() == $groupId) { return $groups[$key]; }
        }
      }
      
      $nl = NULL;
      return $nl;
      ]]></introduction>
      <introduction key="getMemberGroups" class="vo" type="method" value="&amp;getMemberGroups($contactId)"><![CDATA[
      // returns an array of all of the contact groups $contactId is a member of
      $memberGroups = array();
      if ($contactId && ($groups =& $this->getAllGroups())) {
        $keys = array_keys($groups);
        foreach($keys as $key) {
          if ($groups[$key]->isMember($contactId)) { $memberGroups[] =& $groups[$key]; }
        }
        $memberGroups =& SRA_Util::sortObjects($memberGroups, 'getName', FALSE, FALSE);
      }
      
      $nl = NULL;
      return count($memberGroups) ? $memberGroups : $nl;
      ]]></introduction>
      <introduction key="getUserContact" class="vo" type="method" value="&amp;getUserContact($uid=NULL)"><![CDATA[
      // returns the contact for the user specified by $uid. if $uid is not 
      // specified, return the contact for the user that owns this address book. 
      // this method will search contacts, groups and subscriptions
      $uid = $uid ? $uid : $this->getUid();
      
      if ($uid) {
        // contacts
        if ($this->hasBeenSet('contacts')) {
          if ($this->_contacts) {
            $keys = array_keys($this->_contacts);
            foreach($keys as $key) {
              if ($this->_contacts[$key]->getUid() == $uid) { return $this->_contacts[$key]; }
            }
          }
        }
        else if ($contactId = SRA_Database::getQueryValue(SRA_Controller::getAppDb(), 'SELECT contact_id FROM contact WHERE uid=' . $uid . ' AND address_book_id=' . $this->getPrimaryKey())) {
          $dao =& SRA_DaoFactory::getDao('Contact');
          return $dao->findByPk($contactId);
        }
        
        // groups
        if ($groups =& $this->getGroups()) {
          $keys = array_keys($groups);
          foreach($keys as $key) {
            if ($contact =& $groups[$key]->getUserContact($uid)) { return $contact; }
          }
        }
        
        // subscriptions
        if ($groups =& $this->getSubscriptions()) {
          $keys = array_keys($groups);
          foreach($keys as $key) {
            if ($contact =& $groups[$key]->getUserContact($uid)) { return $contact; }
          }
        }
      }
      
      $nl = NULL;
      return $nl;
      ]]></introduction>
      <introduction key="hasGroupReadAccess" class="vo" type="method" value="hasGroupReadAccess($groupId)"><![CDATA[
      // returns true if this address book has read access to the group 
      // specified by $groupId
      return $this->getGroup($groupId) ? TRUE : FALSE;
      ]]></introduction>
      <introduction key="hasGroupWriteAccess" class="vo" type="method" value="hasGroupWriteAccess($groupId)"><![CDATA[
      // returns true if this address book has write access to the group 
      // specified by $groupId
      return $group =& $this->getGroup($groupId) ? $group->canUpdate() : FALSE;
      ]]></introduction>
      <introduction key="includeMyContactsManager" class="vo" type="include" value="plugins/accessories/MyContactsManager.php" />
      <introduction key="searchContacts" class="vo" type="method" value="&amp;searchContacts($search, $attr, $limit, $offset, $groupId)"><![CDATA[
      // searches the contacts in this address book and returns the matches 
      // ordered by the match score. if $groupId is specified, that specified 
      // group will be searched
      if ($groupId) {
        if ($group =& $this->getGroup($groupId)) {
          return $group->searchContacts($search, $attr, $limit, $offset);
        }
        else {
          $msg = 'AddressBookVO::searchContacts: Failed - groupId ' . $groupId . ' is not valid for this address book ' . $this->getPrimaryKey();
          return SRA_Error::logError($msg, __FILE__, __LINE__);
        }
      }
      else {
        return MyContactsManager::_searchContacts($this->getAddressBookId(), $this->getAllGroupIds(), $search, $attr, $limit, $offset);
      }
      ]]></introduction>
    </aop>
    <attribute key="addressBookId" sequence="1" />
    <attribute key="contacts" cardinality="0..*" on-delete-cascade="1" on-remove-delete="1" type="Contact" />
    <attribute key="groups" cardinality="0..*" on-delete-cascade="1" on-remove-delete="1" table-pk-column="address_book" type="ContactGroup" />
    <attribute key="subscriptions" cardinality="0..*" table="address_book_subscriptions" type="ContactGroup" />
    <attribute key="uid" type="int" />
  </entity>
  
  <entity key="Contact" primary-key="contactId" render-append="getContactLabel" render-include="contactId addresses company dates emails gender imIds lastUpdated name note noteHtml otherNames phones pictureUri thumbnailUri uid urls">
    <ajax-service key="retrieveContacts" retrieve="1">
      <ajax-constraint-group key="validatePermissions">
        <ajax-constraint attr="canView" attr-type="getAttr" value="1" />
      </ajax-constraint-group>
    </ajax-service>
    <ajax-service key="updateContacts" create="1" delete="1" retrieve="0" update="1">
      <ajax-constraint-group key="validatePermissions">
        <ajax-constraint attr="canUpdate" attr-type="getAttr" value="1" />
      </ajax-constraint-group>
    </ajax-service>
    <aop>
      <advice key="updateSearchIndex"><![CDATA[
      if ($updated || $inserted) { ContactVO::rebuildSearchIndex($record->getContactId(), $updated); }
      ]]></advice>
      
      <aspect key="deleteRelations" pointcut="dao.delete" when="after"><![CDATA[
      // remove relations where this contact is the target
      if ($deleted) { $this->_db->execute('DELETE FROM contact_relation WHERE target=' . $record->getPrimaryKey()); }
      ]]></aspect>
      <aspect key="getThumbnailUri" pointcut="vo.getThumbnailUri"><![CDATA[
      // return default thumbnail uri if not preset
      if (!$this->_thumbnailUri) { return $this->isCompany() ? CONTACT_MISSING_PICTURE_COMPANY : CONTACT_MISSING_PICTURE; }
      ]]></aspect>
      <aspect key="otherValidation" pointcut="vo.validate" when="after"><![CDATA[
      // validate that either last name or company name have been specified
      if (!$this->validateErrors && (($this->isCompany() && !$this->getCompanyName()) || (!$this->isCompany() && !$this->getLast()))) {
        $this->validateErrors[$this->isCompany() ? 'companyName' : 'last'] = $rb->getString($this->isCompany() ? 'Contact.error.companyNameRequired' : 'Contact.error.lastNameRequired');
      }
      // validate permissions
      if (!$this->validateErrors && $this->recordExists && $this->isDirty()) {
        global $user;
        if ($this->getUid() && (!$user || ($user->getUid() != $this->getUid() && !$user->isChild($this->getUid())))) {
          $this->validateErrors[] = $rb->getString('Contact.error.noPermission');
        }
        else if(!$this->canUpdate()) {
          $this->validateErrors[] = $rb->getString('Contact.error.noPermission');
        }
      }
      ]]></aspect>
      <aspect key="setAddressBook" pointcut="dao.insert"><![CDATA[
      global $user;
      if ($user && !$record->recordExists && !$record->getAddressBook() && !$record->getGroups()) {
        $record->setAddressBook($user->getAddressBook());
      }
      ]]></aspect>
      <aspect key="setLastUpdated" pointcut="vo.validate"><![CDATA[
      // set last updated
      if ($this->isDirty()) { $this->setLastUpdated(new SRA_GregorianDate()); }
      ]]></aspect>
      <aspect key="setNote" pointcut="vo.setNote"><![CDATA[
      // set note to null if default string is set
      if ($note == $this->getEntityResourcesString('text.notSpecified')) { $note = NULL; }
      ]]></aspect>
      <aspect key="updateSearchIndexInsert" advice="updateSearchIndex" pointcut="dao.insert" when="after" />
      <aspect key="updateSearchIndexUpdate" advice="updateSearchIndex" pointcut="dao.update" when="after" />
      <aspect key="verifyDeletePermissions" pointcut="dao.delete"><![CDATA[
      if ($record && $record->recordExists && !$record->canUpdate()) {
        global $user;
        $msg = 'ContactDAO::delete: Failed - user ' . ($user ? $user->getName() . ' ' : '') . 'does not have permissions to delete the contact ' . $record->getContactLabel();
        return SRA_Error::logError($msg, __FILE__, __LINE__);
      }
      ]]></aspect>
      
      <introduction key="canUpdate" class="vo" type="method" value="canUpdate($contactId=NULL)"><![CDATA[
      // returns TRUE if the current user can update this contact. can also be 
      // invoked statically using the $contactId parameter
      return !$this->recordExists || ($contactId ? ContactVO::getAccess($contactId) : $this->getAccess()) == 2;
      ]]></introduction> 
      <introduction key="canView" class="vo" type="method" value="canView($contactId=NULL)"><![CDATA[
      // returns TRUE if the current user can view this contact. can also be 
      // invoked statically using the $contactId parameter
      return !$this->recordExists || ($contactId ? ContactVO::getAccess($contactId) : $this->getAccess()) >= 1;
      ]]></introduction> 
      <introduction key="getAccess" class="vo" type="method" value="getAccess($contactId=NULL)"><![CDATA[
      // returns the access level of the current active user to this contact. 
      // this value will be 0 for no access, 1 for read-only access and 2 for 
      // write access. can also be invoked statically using the $contactId 
      // parameter
      global $user;
      
      if ($contactId) {
        $dao =& SRA_DaoFactory::getDao('Contact');
        $contact =& $dao->findByPk($contactId);
      }
      else {
        $contact =& $this;
      }
      $permissions = 0;
      if (OsUserVO::isValid($user) && ContactVO::isValid($contact)) {
        if ($contact->recordExists) {
          static $_contactAccess = array();
          if (!isset($_contactAccess[$contact->getContactId()])) {
            $addressBook =& $user->getAddressBook();
            // contact belongs to user's (or child) address book
            if (($ab =& $contact->getAddressBook()) && ($addressBook->equals($ab) || $user->isChild($ab->getUid()))) {
              $permissions = 2;
            }
            // contact belongs to an address book group
            else if ($groups =& $contact->getGroups()) {
              $keys = array_keys($groups);
              foreach($keys as $key) {
                if ($groups[$key]->getAccess() > $permissions) { $permissions = $groups[$key]->getAccess(); }
                if ($permissions == 2) { break; }
              }
            }
            $_contactAccess[$contact->getContactId()] = $permissions;
          }
          else {
            $permissions = $_contactAccess[$contact->getContactId()];
          }
        }
        // new contact
        else {
          $permissions = 2;
        }
      }
      return $permissions;
      ]]></introduction>
      <introduction key="getAddress" class="vo" type="method" value="&amp;getAddress($type)"><![CDATA[
      // returns the address of the type specified (or NULL if it does not exist)
      return $this->_getTypeSpecificAttribute('addresses', $type);
      ]]></introduction> 
      <introduction key="getAllRelations" class="vo" type="method" value="&amp;getAllRelations()"><![CDATA[
      // returns both explicit and implicit relations
      if (!isset($this->_implicitRelations)) {
        $this->_implicitRelations = array();
        $inverseBundle =& SRA_ResourceBundle::getBundle(ContactRelationVO::getOptionsBundle('type') . '-inverse-mappings');
        if (SRA_ResourceBundle::isValid($inverseBundle) && $this->getPrimaryKey()) {
          $dao =& SRA_DaoFactory::getDao('ContactRelation');
          $implicitRelations =& $dao->findByQuery('SELECT relation_id FROM contact_relation WHERE target=' . $this->getPrimaryKey());
          $keys = array_keys($implicitRelations);
          foreach($keys as $key) {
            // only add if inverse relation exists in 'relations-inverse-mappings.properties'
            if ($inverseBundle->containsKey($implicitRelations[$key]->getType())) {
              $idx = count($this->_implicitRelations);
              $this->_implicitRelations[$idx] =& $implicitRelations[$key]->copy();
              $this->_implicitRelations[$idx]->setTarget($this->_implicitRelations[$idx]->getSource());
              $this->_implicitRelations[$idx]->setSource($this->getPrimaryKey());
              $this->_implicitRelations[$idx]->setType($inverseBundle->getString($this->_implicitRelations[$idx]->getType()));
            }
          }
        }
      }
      $this->getRelations();
      if (count($this->_implicitRelations)) {
        $relations = array();
        $existingRelations = array();
        if ($this->_relations) {
          $keys = array_keys($this->_relations);
          foreach($keys as $key) {
            $relations[] =& $this->_relations[$key];
            $existingRelations[] = $this->_relations[$key]->getTarget() . $this->_relations[$key]->getType();
          }
        }
        $keys = array_keys($this->_implicitRelations);
        foreach($keys as $key) {
          if (!in_array($this->_implicitRelations[$key]->getTarget() . $this->_implicitRelations[$key]->getType(), $existingRelations)) {
            $relations[] =& $this->_implicitRelations[$key];
          }
        }
      }
      return $relations ? $relations : $this->getRelations();
      ]]></introduction>
      <introduction key="getContactIdInitArray" class="vo" type="method" value="getContactIdInitArray()"><![CDATA[
      // returns an associative array with a single key 'contactId' where the 
      // value is this contact's contact id
      return array('contactId' => $this->getContactId());
      ]]></introduction> 
      <introduction key="getContactLabel" class="vo" type="method" value="getContactLabel()"><![CDATA[
      // returns the correct label to use for this contact depending on whether 
      // it is a person or a company
      return $this->_name->getNameLabel();
      ]]></introduction>
      <introduction key="getDate" class="vo" type="method" value="&amp;getDate($type)"><![CDATA[
      // returns the date of the type specified (or NULL if it does not exist)
      return $this->_getTypeSpecificAttribute('dates', $type);
      ]]></introduction> 
      <introduction key="getEmail" class="vo" type="method" value="&amp;getEmail($type)"><![CDATA[
      // returns the email of the type specified (or NULL if it does not exist)
      return $this->_getTypeSpecificAttribute('emails', $type);
      ]]></introduction> 
      <introduction key="getFullName" class="vo" type="method" value="getFullName()"><![CDATA[
      // returns the full name to use for this contact
      return $this->_name->getFullName();
      ]]></introduction>
      <introduction key="getGenderValue" class="vo" type="method" value="getGenderValue()"><![CDATA[
      // returns the gender label (Male or Female) if a gender has been set, NULL 
      //otherwise
      return $this->_gender ? $this->getEntityResourcesString('Contact.gender.' . $this->_gender) : NULL;
      ]]></introduction>
      <introduction key="getGroupOptions" class="vo" type="method" value="getGroupOptions()"><![CDATA[
      // returns the group options for this contact
      global $user;
      $options = array();
      if ($user && ($ab =& $user->getAddressBook()) && ($hash = $ab->getAllGroupsHash())) {
        foreach($hash as $group) {
          if (!$group['isReadOnly']) { $options[$group['groupId']] = $group['name']; }
        }
      }
      return $options;
      ]]></introduction>
      <introduction key="getImId" class="vo" type="method" value="&amp;getImId($type)"><![CDATA[
      // returns the IM id of the type specified (or NULL if it does not exist)
      return $this->_getTypeSpecificAttribute('imIds', $type);
      ]]></introduction>
      <introduction key="getPhone" class="vo" type="method" value="&amp;getPhone($type)"><![CDATA[
      // returns the phone of the type specified (or NULL if it does not exist)
      return $this->_getTypeSpecificAttribute('phones', $type);
      ]]></introduction> 
      <introduction key="getPhoneticFullName" class="vo" type="method" value="getPhoneticFullName()"><![CDATA[
      // returns the phonetic full name (if applicable) to use for this contact
      return $this->_name->getPhoneticFullName();
      ]]></introduction>
      <introduction key="getUrl" class="vo" type="method" value="&amp;getUrl($type)"><![CDATA[
      // returns the url of the type specified (or NULL if it does not exist)
      return $this->_getTypeSpecificAttribute('urls', $type);
      ]]></introduction> 
      <introduction key="includeCore_Services" class="vo" type="include" value="plugins/core/Core_Services.php" />
      <introduction key="rebuildSearchIndex" class="vo" type="method" value="rebuildSearchIndex($contactId=NULL, $queue=TRUE)"><![CDATA[
      // static method used to rebuild the search index of this contact. can 
      // also be invoked statically using the $contactId parameter. if $queue is 
      // TRUE (default), the rebuild operation will be delayed until completion 
      // of the current PHP process
      static $_rebuildQueued = array();
      
      $contactId = $contactId ? $contactId : (method_exists($this, 'getContactId') ? $this->getContactId() : NULL);
      if (!$contactId) { return; }
      
      if ($queue) {
        if (!isset($_rebuildQueued[$contactId])) {
          $_rebuildQueued[$contactId] = TRUE;
          $className = 'ContactVO';
          SRA_Controller::registerShutdownMethod($className, 'rebuildSearchIndex', array($contactId, FALSE));
        }
        return;
      }
      
      if (isset($_rebuildQueued[$contactId])) { unset($_rebuildQueued[$contactId]); }
      
      $db =& SRA_Controller::getAppDb();
      $query = 'SELECT company_name, department, first, job_title, last, maiden, middle, nickname, phonetic_first, phonetic_last, phonetic_middle, note FROM contact WHERE contact_id=' . $db->convertInt($contactId);
      $results =& $db->fetch($query);
      if ($results->count()) {
        $row =& $results->next();
        $searchIndex = SRA_Util::implodeSkipEmpty(' ', $row);
        
        $results =& $db->fetch('SELECT country, locality, postal_code, region, street FROM contact_address WHERE contact_id=' . $contactId);
        while($row =& $results->next()) {
          $searchIndex .= SRA_Util::implodeSkipEmpty(' ', $row, TRUE);
        }
        
        $results =& $db->fetch('SELECT date, location FROM contact_date WHERE contact_id=' . $contactId);
        while($row =& $results->next()) {
          $searchIndex .= SRA_Util::implodeSkipEmpty(' ', $row, TRUE);
        }
        
        $results =& $db->fetch('SELECT email FROM contact_email WHERE contact_id=' . $contactId);
        while($row =& $results->next()) {
          $searchIndex .= SRA_Util::implodeSkipEmpty(' ', $row, TRUE);
        }
        
        $results =& $db->fetch('SELECT id FROM contact_im_id WHERE contact_id=' . $contactId);
        while($row =& $results->next()) {
          $searchIndex .= SRA_Util::implodeSkipEmpty(' ', $row, TRUE);
        }
        
        $results =& $db->fetch('SELECT company_name, department, first, job_title, last, maiden, middle, name_note, nickname, phonetic_first, phonetic_last, phonetic_middle FROM contact_name WHERE contact_id=' . $db->convertInt($contactId));
        while($row =& $results->next()) {
          $searchIndex .= SRA_Util::implodeSkipEmpty(' ', $row, TRUE);
        }
        
        $results =& $db->fetch('SELECT number FROM contact_phone WHERE contact_id=' . $contactId);
        while($row =& $results->next()) {
          $searchIndex .= SRA_Util::implodeSkipEmpty(' ', $row, TRUE);
        }
        
        $results =& $db->fetch('SELECT url FROM contact_url WHERE contact_id=' . $contactId);
        while($row =& $results->next()) {
          $searchIndex .= SRA_Util::implodeSkipEmpty(' ', $row, TRUE);
        }
        
        // MyContacts search extensions
        if ($params = SRA_Controller::getAppParams(NULL, 'my-contacts-search')) {
          $dao =& SRA_DaoFactory::getDao('Contact');
          $contact =& $dao->findByPk($contactId);
          
          if ($contact) {
            $attrs = array_keys($params);
            foreach($attrs as $attr) {
              if (($attr = $contact->getAttribute($attr)) && (is_scalar($attr) || is_array($attr))) {
                $searchIndex .= (is_array($attr) ? SRA_Util::implodeSkipEmpty(' ', $attr, TRUE) : ' ' . $attr);
              }
            }
          }
        }
        
        if (SRA_Database::getRecordCount($db, 'SELECT contact_id FROM contact_search_index WHERE contact_id=' . $contactId)) {
          $db->execute('UPDATE contact_search_index SET search_index=' . $db->convertText($searchIndex) . ' WHERE contact_id=' . $contactId);
        }
        else {
          $db->execute('INSERT INTO contact_search_index (contact_id, search_index) VALUES (' . $contactId . ', ' . $db->convertText($searchIndex) . ')');
        }
      }
      ]]></introduction>
      
      <introduction key="_getTypeSpecificAttribute" class="vo" type="method" value="&amp;_getTypeSpecificAttribute($attribute, $type)"><![CDATA[
      // returns a type specific relational attribute (or NULL if it does not exist)
      $attr = NULL;
      if (is_array($attrs =& $this->getAttribute($attribute))) {
        $keys = array_keys($attrs);
        foreach($keys as $key) {
          if (method_exists($attrs[$key], 'getType') && $attrs[$key]->getType() == $type) {
            $attr =& $attrs[$key];
            break;
          }
        }
      }
      return $attr;
      ]]></introduction> 
      <introduction key="CONTACT_MISSING_PICTURE" class="vo" type="constant" value="CONTACT_MISSING_PICTURE='images/no-picture.jpg'" />
      <introduction key="CONTACT_MISSING_PICTURE_COMPANY" class="vo" type="constant" value="CONTACT_MISSING_PICTURE_COMPANY='plugins/accessories/images/no-picture-company.jpg'" />
    </aop>
    <attribute key="contactId" sequence="1" />
    <attribute key="addressBook" column="address_book_id" type="AddressBook" />
    <attribute key="addresses" cardinality="0..*" on-delete-cascade="1" on-remove-delete="1" type="ContactAddress">
      <view key="form" render-attributes="1" />
      <view key="input" render-attributes="1" />
    </attribute>
    <attribute key="dates" cardinality="0..*" on-delete-cascade="1" on-remove-delete="1" type="ContactDate">
      <view key="input" render-attributes="1" />
    </attribute>
    <attribute key="emails" cardinality="0..*" on-delete-cascade="1" on-remove-delete="1" type="ContactEmail">
      <view key="input" render-attributes="1" />
    </attribute>
    <attribute key="gender" depends="option" max-length="1">
      <var key="options" value="Contact.gender.f=f Contact.gender.m=m" />
      <view key="field" extends="input-select">
        <param id="class" type="select-attrs" value="myContactCardField" />
      </view>
      <view key="input" extends="input-ci">
        <param id="view" value="outputText" />
      </view>
      <view key="output" template="plugins/accessories/_contact-gender.tpl" />
      <view key="outputText" extends="option" />
    </attribute>
    <attribute key="groups" cardinality="0..*" depends="options" table="group_contacts" type="ContactGroup">
      <var key="code" value="$options = ContactVO::getGroupOptions();" />
      <view key="input" extends="input-checkboxes" />
      <view key="output" template="plugins/accessories/_contact-groups.tpl" />
    </attribute>
    <attribute key="imbedded" default="FALSE" type="boolean">
      <view key="output" extends="input-hidden" />
    </attribute>
    <attribute key="imIds" cardinality="0..*" on-delete-cascade="1" on-remove-delete="1" type="ContactImId">
      <view key="input" render-attributes="1" />
    </attribute>
    <attribute key="lastUpdated" default="new SRA_GregorianDate()" type="date" />
    <attribute key="name" aggregate="1" default="new ContactNameVO()" mapped="1" mapped-include="company companyName department first jobTitle last maiden middle nickname phoneticFirst phoneticLast phoneticMiddle prefix suffix" type="ContactName" />
    <attribute key="note" max-length="2097152" set-convert="strip_tags" sync-attributes="noteHtml">
      <view key="input" extends="input-textarea-ci">
        <param id="noValueResource" value="text.notSpecified" />
      </view>
    </attribute>
    <attribute key="noteHtml" max-length="2097152" set-convert="Core_Services_wikiToHtml" />
    <attribute key="otherNames" cardinality="0..*" on-delete-cascade="1" on-remove-delete="1" type="ContactName">
      <view key="fields" render-attributes="1" />
      <view key="input" render-attributes="1" />
    </attribute>
    <attribute key="phones" cardinality="0..*" on-delete-cascade="1" on-remove-delete="1" type="ContactPhone">
      <view key="input" render-attributes="1" />
    </attribute>
    <attribute key="picture" depends="maxFileSize mimeType" file-uri-attr="pictureUri" is-file="1" lazy-load-exclusive="1">
      <thumbnail key="thumbnail" width="50" />
      <var key="maxFileSize" value="2097152" />
      <var key="mimeTypes" value="image/[gif|jpeg|png]" />
      <view key="field" extends="input-file" />
      <view key="input" extends="input-ci">
        <param id="showLabel" value="0" />
        <param id="syncValue" value="1" />
      </view>
      <view key="output" template="plugins/accessories/_contact-picture.tpl">
        <param id="editMode" value="1" />
      </view>
      <view key="outputView" template="plugins/accessories/_contact-picture.tpl" />
    </attribute>
    <attribute key="pictureUri" max-length="255" />
    <attribute key="relations" cardinality="0..*" on-delete-cascade="1" on-remove-delete="1" table-pk-column="source" type="ContactRelation">
      <view key="input" render-attributes="1" />
    </attribute>
    <attribute key="searchIndex" max-length="16777215" table="contact_search_index" />
    <attribute key="thumbnail" file-uri-attr="thumbnailUri" is-file="1" lazy-load-exclusive="1" />
    <attribute key="thumbnailUri" max-length="255" />
    <attribute key="uid" depends="unique" type="int" />
    <attribute key="urls" cardinality="0..*" on-delete-cascade="1" on-remove-delete="1" type="ContactUrl">
      <view key="input" render-attributes="1" />
    </attribute>
    
    <view key="input" template="plugins/accessories/contact-form.tpl" />
    <view key="input-name" template="plugins/accessories/contact-form-name.tpl" />
		<view key="view" template="plugins/accessories/contact.tpl" />
  </entity>
  
  <entity key="ContactAddress" primary-key="addressId">
    <aop>
      <advice key="updateSearchIndex"><![CDATA[
      if (($updated || $inserted) && (isset($oldDirtyFlags['country']) || isset($oldDirtyFlags['locality']) || isset($oldDirtyFlags['postalCode']) || isset($oldDirtyFlags['region']) || isset($oldDirtyFlags['street']))) { ContactVO::rebuildSearchIndex($record->getContactId()); }
      ]]></advice>
      
      <aspect key="getCountryLabel" pointcut="vo.getCountryLabel" when="after"><![CDATA[
      // return country specific label for this attribute
      if (SRA_AddressFormat::isValid($af =& $this->getAddressFormatObject())) { return $af->getLabel('country'); }
      ]]></aspect>
      <aspect key="getLocalityLabel" pointcut="vo.getLocalityLabel" when="after"><![CDATA[
      // return locality specific label for this attribute
      if (SRA_AddressFormat::isValid($af =& $this->getAddressFormatObject())) { return $af->getLabel('locality'); }
      ]]></aspect>
      <aspect key="getPostalCodeLabel" pointcut="vo.getPostalCodeLabel" when="after"><![CDATA[
      // return postalCode specific label for this attribute
      if (SRA_AddressFormat::isValid($af =& $this->getAddressFormatObject())) { return $af->getLabel('postalCode'); }
      ]]></aspect>
      <aspect key="getRegionLabel" pointcut="vo.getRegionLabel" when="after"><![CDATA[
      // return region specific label for this attribute
      if (SRA_AddressFormat::isValid($af =& $this->getAddressFormatObject())) { return $af->getLabel('region'); }
      ]]></aspect>
      <aspect key="getStreetLabel" pointcut="vo.getStreetLabel" when="after"><![CDATA[
      // return street specific label for this attribute
      if (SRA_AddressFormat::isValid($af =& $this->getAddressFormatObject())) { return $af->getLabel('street'); }
      ]]></aspect>
      <aspect key="otherValidation" pointcut="vo.validate" when="after"><![CDATA[
      // validates the data in this address using the address format (SRA_AddressFormat)
      // can be bypassed by setting the instance attribute 'skipAddressFormatValidation' 
      // to TRUE
      if (!$this->skipAddressFormatValidation && !$this->validateErrors && $this->isDirty()) {
        $addressFormat =& $this->getAddressFormatObject();
        if (is_array($errs = $addressFormat->validateFieldValues($this))) {
          $keys = array_keys($errs);
          foreach($keys as $key) {
            $params = array('attr' => $addressFormat->getLabel($key));
            $this->validateErrors[$key] = $rb->getString($errs[$key] == 'required' ? 'error.required' : 'error.mask', $params);
          }
        }
      }
      ]]></aspect>
      <aspect key="removeLabelCountry" pointcut="vo.setCountry"><![CDATA[
      if (SRA_AddressFormat::isFieldLabel('country', $country)) { $country = NULL; }
      ]]></aspect>
      <aspect key="removeLabelLocality" pointcut="vo.setLocality"><![CDATA[
      if (SRA_AddressFormat::isFieldLabel('locality', $locality)) { $locality = NULL; }
      ]]></aspect>
      <aspect key="removeLabelPostalCode" pointcut="vo.setPostalCode"><![CDATA[
      if (SRA_AddressFormat::isFieldLabel('postalCode', $postalCode)) { $postalCode = NULL; }
      ]]></aspect>
      <aspect key="removeLabelRegion" pointcut="vo.setRegion"><![CDATA[
      if (SRA_AddressFormat::isFieldLabel('region', $region)) { $region = NULL; }
      ]]></aspect>
      <aspect key="removeLabelStreet" pointcut="vo.setStreet"><![CDATA[
      if (SRA_AddressFormat::isFieldLabel('street', $street)) { $street = NULL; }
      ]]></aspect>
      <aspect key="setCountryCode" pointcut="vo.setCountry"><![CDATA[
      // convert country name to country code
      if ($country) { $country = SRA_Country::getCode($country); }
      ]]></aspect>
      <aspect key="setDefaultCountry" pointcut="vo.ContactAddressVO" when="after"><![CDATA[
      // set default country for this address
      if (!$this->_country) {
        $addressFormat =& $this->getAddressFormatObject();
        $this->setCountry($addressFormat->country);
      }
      ]]></aspect>
      <aspect key="setRegionCode" pointcut="vo.setRegion"><![CDATA[
      // convert region name to region code
      if ($code = SRA_Country::getProvinceCode($region, $this->_country)) { $region = $code; }
      ]]></aspect>
      <aspect key="updateSearchIndexInsert" advice="updateSearchIndex" pointcut="dao.insert" when="after" />
      <aspect key="updateSearchIndexUpdate" advice="updateSearchIndex" pointcut="dao.update" when="after" />
      
      <introduction key="getAddressFormatObject" class="vo" type="method" value="&amp;getAddressFormatObject()"><![CDATA[
      // returns the SRA_AddressFormat object for this address
      return SRA_AddressFormat::getInstance($this->_country);
      ]]></introduction>
      <introduction key="getContact" class="vo" type="method" value="&amp;getContact()"><![CDATA[
      // returns a reference to the contact associated with this address
      $contact = NULL;
      if ($this->_contactId) {
        $dao =& SRA_DaoFactory::getDao('Contact');
        $contact =& $dao->findByPk($this->_contactId);
      }
      return $contact;
      ]]></introduction>
      <introduction key="getCountryName" class="vo" type="method" value="getCountryName()"><![CDATA[
      // returns the full country name
      return SRA_Country::getCountryName($this->_country);
      ]]></introduction>
      <introduction key="getProvinceName" class="vo" type="method" value="getProvinceName()"><![CDATA[
      // returns the full province (region) name (if available)
      return $name = SRA_Country::getProvinceName($this->_region, $this->_country) ? $name : $this->_region;
      ]]></introduction>
      <introduction key="includeAddressFormat" class="vo" type="include" value="util/l10n/SRA_AddressFormat.php" />
      <introduction key="includeCountry" class="vo" type="include" value="util/l10n/SRA_Country.php" />
    </aop>
    <attribute key="addressId" sequence="1">
      <view key="output" extends="input-hidden" />
    </attribute>
    <attribute key="contactId" type="int" />
    <attribute key="country" default="US" max-length="2" depends="option required">
      <var key="code" value="$options =&amp; SRA_AddressFormat::getCountries();" />
      <view key="field" extends="input-select-required">
        <param id="class" type="select-attrs" value="myContactCardField" />
        <param id="onchange" type="select-attrs" value="MyContacts._currentInstance.updateAddressCountry(this);" />
      </view>
      <view key="input" extends="input-ci" />
      <view key="output" extends="option" />
    </attribute>
    <attribute key="locality" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="postalCode" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="region" max-length="128">
      <view key="input" extends="input-text-ci">
        <param id="autocomplete" type="input-attrs" value="off" />
        <param id="onfocus" type="input-attrs" value="MyContacts._currentInstance.addAjaxRegionLookup(this);" />
        <param id="value" type="encl" value="span" />
      </view>
    </attribute>
    <attribute key="street">
      <view key="input" extends="input-textarea-ci">
        <param id="rows" value="1" />
      </view>
    </attribute>
    <attribute key="type" default="'home'" depends="required" max-length="64" resource="text.type" xml-use-attribute="1">
      <var key="resources" value="etc/plugins/accessories/l10n/contact-attr-types" />
      <view key="field" extends="input-select-other">
        <param id="class" type="select-attrs" value="myContactCardField" />
        <param id="otherOptionCallback" value="MyContacts._currentInstance.updateTypeLabel" />
      </view>
      <view key="input" extends="input-ci">
        <param id="labelClass" value="editModeSelector" />
      </view>
      <view key="output" extends="option" />
    </attribute>
    
    <view key="form" template="l10n/sra-address.tpl">
      <param id="address" type="class" value="addressForm" />
      <param id="view" value="input" />
    </view>
    <view key="input" template="plugins/accessories/contact-address-form.tpl" />
    <view key="output" template="l10n/sra-address.tpl">
      <param id="address" type="class" value="addressView" />
    </view>
  </entity>
  
  <entity key="ContactDate" primary-key="dateId">
    <aop>
      <advice key="updateSearchIndex"><![CDATA[
      if (($updated || $inserted) && (isset($oldDirtyFlags['date']) || isset($oldDirtyFlags['location']))) { ContactVO::rebuildSearchIndex($record->getContactId()); }
      ]]></advice>
      
      <aspect key="updateSearchIndexInsert" advice="updateSearchIndex" pointcut="dao.insert" when="after" />
      <aspect key="updateSearchIndexUpdate" advice="updateSearchIndex" pointcut="dao.update" when="after" />
      
      <introduction key="getContact" class="vo" type="method" value="&amp;getContact()"><![CDATA[
      // returns a reference to the contact associated with this date
      $contact = NULL;
      if ($this->_contactId) {
        $dao =& SRA_DaoFactory::getDao('Contact');
        $contact =& $dao->findByPk($this->_contactId);
      }
      return $contact;
      ]]></introduction>
    </aop>
    <attribute key="dateId" sequence="1">
      <view key="output" extends="input-hidden" />
    </attribute>
    <attribute key="contactId" type="int" />
    <attribute key="date" depends="required" type="date">
      <view key="field" extends="input-date-chooser-ci">
        <param id="class" type="input-attrs" value="myContactCardDateField" />
      </view>
      <view key="input" extends="input-ci" />
      <view key="output" extends="date" />
    </attribute>
    <attribute key="location" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="type" depends="required" max-length="64" resource="text.type" xml-use-attribute="1">
      <var key="resources" value="etc/plugins/accessories/l10n/date-types" />
      <view key="field" extends="input-select-other">
        <param id="class" type="select-attrs" value="myContactCardField" />
        <param id="otherOptionCallback" value="MyContacts._currentInstance.updateTypeLabel" />
      </view>
      <view key="input" extends="input-ci">
        <param id="labelClass" value="editModeSelector" />
      </view>
      <view key="output" extends="option" />
    </attribute>
    
    <view key="input" template="plugins/accessories/contact-date-form.tpl" />
  </entity>
  
  <entity key="ContactEmail" primary-key="emailId">
    <aop>
      <advice key="updateSearchIndex"><![CDATA[
      if (($updated || $inserted) && (isset($oldDirtyFlags['email']))) { ContactVO::rebuildSearchIndex($record->getContactId()); }
      ]]></advice>
      
      <aspect key="updateSearchIndexInsert" advice="updateSearchIndex" pointcut="dao.insert" when="after" />
      <aspect key="updateSearchIndexUpdate" advice="updateSearchIndex" pointcut="dao.update" when="after" />
      
      <introduction key="getContact" class="vo" type="method" value="&amp;getContact()"><![CDATA[
      // returns a reference to the contact associated with this email
      $contact = NULL;
      if ($this->_contactId) {
        $dao =& SRA_DaoFactory::getDao('Contact');
        $contact =& $dao->findByPk($this->_contactId);
      }
      return $contact;
      ]]></introduction>
    </aop>
    <attribute key="emailId" sequence="1">
      <view key="output" extends="input-hidden" />
    </attribute>
    <attribute key="contactId" type="int" />
    <attribute key="email" depends="email required" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="type" default="'home'" depends="required" max-length="64" resource="text.type" xml-use-attribute="1">
      <var key="resources" value="etc/plugins/accessories/l10n/contact-attr-types" />
      <view key="field" extends="input-select-other">
        <param id="class" type="select-attrs" value="myContactCardField" />
        <param id="otherOptionCallback" value="MyContacts._currentInstance.updateTypeLabel" />
      </view>
      <view key="input" extends="input-ci">
        <param id="labelClass" value="editModeSelector" />
      </view>
      <view key="output" extends="option" />
    </attribute>
    
    <view key="input" template="plugins/accessories/contact-email-form.tpl" />
  </entity>
  
  <entity key="ContactGroup" primary-key="groupId" render-append="getAccessRestrictionsHash" render-exclude="addressBook contacts subscribedToBy publicGids publicUids">
    <ajax-service key="manageContactGroups" create="1" delete="1" update="1">
      <ajax-constraint-group key="validatePermissions">
        <ajax-constraint attr="canUpdate" attr-type="getAttr" value="1" />
      </ajax-constraint-group>
    </ajax-service>
    <aop>
      <aspect key="otherValidation" pointcut="vo.validate" when="after"><![CDATA[
      // validate that either last name or company name have been specified
      if (!$this->validateErrors && $this->recordExists && $this->isDirty() && !$this->canUpdate()) {
        $this->validateErrors[] = $rb->getString('ContactGroup.error.noPermission');
      }
      ]]></aspect>
      <aspect key="removeSubscriptions" pointcut="dao.update" when="after"><![CDATA[
      // remove any subscriptions that are no longer allowed
      if ($updated) { $record->removeSubscriptions($oldDirtyFlags); }
      ]]></aspect>
      <aspect key="verifyDeletePermissions" pointcut="dao.delete"><![CDATA[
      if ($record && $record->recordExists && !$record->canUpdate()) {
        global $user;
        $msg = 'ContactDAO::delete: Failed - user ' . ($user ? $user->getName() . ' ' : '') . 'does not have permissions to delete the contact group ' . $record->getGroupId();
        return SRA_Error::logError($msg, __FILE__, __LINE__);
      }
      ]]></aspect>
      
      <introduction key="canSubscribe" class="vo" type="method" value="canSubscribe($uid)"><![CDATA[
      // returns true if the user identified by $uid can subscribe to this 
      // contact group
      if ($uid && $this->isPublic()) {
        if (!$this->getPublicGids() && !$this->getPublicUids()) {
          return TRUE;
        }
        else {
          $gids = $this->getPublicGids();
          $uids = $this->getPublicUids();
          if ($uids && in_array($uid, $uids)) { return TRUE; }
          if ($gids) {
            foreach($gids as $gid) {
              $users = OsGroupVO::getUserHash($gid);
              if (isset($users[$uid])) { return TRUE; }
            }
          }
        }
      }
      return FALSE;
      ]]></introduction>
      <introduction key="canUpdate" class="vo" type="method" value="canUpdate($groupId=NULL)"><![CDATA[
      // returns TRUE if the current user can update this contact group. can 
      // also be invoked statically using the $groupId parameter
      return !$this->recordExists || ($groupId ? ContactGroupVO::getAccess($groupId) : $this->getAccess()) == 2;
      ]]></introduction> 
      <introduction key="canView" class="vo" type="method" value="canView($groupId=NULL)"><![CDATA[
      // returns TRUE if the current user can view this contact group. can also 
      // be invoked statically using the $groupId parameter
      return !$this->recordExists || ($groupId ? ContactGroupVO::getAccess($groupId) : $this->getAccess()) >= 1;
      ]]></introduction> 
      <introduction key="getAccess" class="vo" type="method" value="getAccess($groupId=NULL)"><![CDATA[
      // returns the access level of the current active user to this contact 
      // group. this value will be 0 for no access, 1 for read-only access and 2 
      // for write access. can also be invoked statically using the $groupId 
      // parameter
      global $user;
      
      if ($groupId) {
        $dao =& SRA_DaoFactory::getDao('ContactGroup');
        $group =& $dao->findByPk($groupId);
      }
      else {
        $group =& $this;
      }
      $permissions = 0;
      if (OsUserVO::isValid($user) && ContactGroupVO::isValid($group)) {
        static $_contactGroupAccess = array();
        if (!isset($_contactGroupAccess[$group->getGroupId()])) {
          $addressBook =& $user->getAddressBook();
          // group is part of a user group
          if ($group->getGid()) {
            $userGroupDao =& SRA_DaoFactory::getDao('OsGroup');
            $userGroup =& $userGroupDao->findByPk($group->getGid());
            $permissions = in_array($userGroup->getOwnerUid(), $user->getAllUids()) ? 2 : ($user->isMemberOfGroup($userGroup) ? 1 : 0);
          }
          // group belongs to user's (or child) address book
          else if (($ab =& $group->getAddressBook()) && ($addressBook->equals($ab) || $user->isChild($ab->getUid()))) {
            $permissions = 2;
          }
          // group is subscribed to
          else if ($addressBook->getGroup($group->getGroupId())) {
            $permissions = $group->isPublicReadOnly() ? 1 : 2;
          }
          $_contactGroupAccess[$group->getGroupId()] = $permissions;
        }
        else {
          $permissions = $_contactGroupAccess[$group->getGroupId()];
        }
      }
      return $permissions;
      ]]></introduction>
      <introduction key="getAccessRestrictionsHash" class="vo" type="method" value="getAccessRestrictionsHash()"><![CDATA[
      // returns the access restrictions for this group as a hash indexed by 
      // group or user id (group ids will be prefixed with 'g') where the value 
      // is the user or group name. the hash will also be sorted
      $restrictions = array();
      if ($gids = $this->getPublicGids()) {
        foreach($gids as $gid) {
          $restrictions['g' . $gid] = OsGroupVO::getNameFromGid($gid);
        }
      }
      if ($uids = $this->getPublicUids()) {
        foreach($uids as $uid) {
          $restrictions[$uid] = OsUserVO::getNameFromUid($uid);
        }
      }
      asort($restrictions);
      return count($restrictions) ? $restrictions : NULL;
      ]]></introduction>
      <introduction key="getContact" class="vo" type="method" value="&amp;getContact($contactId)"><![CDATA[
      // returns the Contact record for $contactId if it pertains to this group
      if ($contactId) {
        if ($this->hasBeenSet('contacts')) {
          if ($this->_contacts) {
            $keys = array_keys($this->_contacts);
            foreach($keys as $key) {
              if ($this->_contacts[$key]->getContactId() == $contactId) { return $this->_contacts[$key]; }
            }
          }
        }
        else if (SRA_Database::getQueryValue(SRA_Controller::getAppDb(), 'SELECT c.contact_id FROM group_contacts g, contact c WHERE g.group_id=' . $this->getPrimaryKey() . ' AND c.contact_id=' . $contactId . ' AND g.contact_id=c.contact_id')) {
          $dao =& SRA_DaoFactory::getDao('Contact');
          return $dao->findByPk($contactId);
        }
      }
      
      $nl = NULL;
      return $nl;
      ]]></introduction>
      <introduction key="getContactIds" class="vo" type="method" value="getContactIds()"><![CDATA[
      // returns the ids of all of the contacts in this address book
      $db =& SRA_Controller::getAppDb();
      $contactIds = array();
      
      $results =& $db->fetch('SELECT contact_id FROM group_contacts WHERE group_id=' . $this->getPrimaryKey());
      while($row =& $results->next()) {
        $contactIds[] = $row[0];
      }
      
      return $contactIds;
      ]]></introduction>
      <introduction key="getUserContact" class="vo" type="method" value="&amp;getUserContact($uid)"><![CDATA[
      // returns the Contact record for the user specified by $uid if it exists 
      // in this group
      if ($uid) {
        if ($this->hasBeenSet('contacts')) {
          if ($this->_contacts) {
            $keys = array_keys($this->_contacts);
            foreach($keys as $key) {
              if ($this->_contacts[$key]->getUid() == $uid) { return $this->_contacts[$key]; }
            }
          }
        }
        else if ($contactId = SRA_Database::getQueryValue(SRA_Controller::getAppDb(), 'SELECT c.contact_id FROM group_contacts g, contact c WHERE g.group_id=' . $this->getPrimaryKey() . ' AND c.uid=' . $uid . ' AND g.contact_id=c.contact_id')) {
          $dao =& SRA_DaoFactory::getDao('Contact');
          return $dao->findByPk($contactId);
        }
      }
      
      $nl = NULL;
      return $nl;
      ]]></introduction>
      <introduction key="includeMyContactsManager" class="vo" type="include" value="plugins/accessories/MyContactsManager.php" />
      <introduction key="isMember" class="vo" type="method" value="isMember($contactId, $groupId=NULL)"><![CDATA[
      // returns TRUE if the contact identified by $contactId is a member of 
      // this group. can also be invoked statically using the $groupId parameter
      $db =& SRA_Controller::getAppDb();
      return SRA_Database::getQueryValue($db, 'SELECT count(*) FROM group_contacts WHERE group_id=' . ($groupId ? $groupId : $this->getGroupId()) . ' AND contact_id=' . $db->convertInt($contactId), SRA_DATA_TYPE_INT) > 0;
      ]]></introduction>
      <introduction key="removeSubscriptions" class="vo" type="method" value="removeSubscriptions($oldDirtyFlags)"><![CDATA[
      // invoked after an update to remove any subscriptions that are no longer 
      // allowed to this group
      $db =& SRA_Controller::getAppDb();
      if (isset($oldDirtyFlags['public']) && !$this->isPublic()) {
        $db->execute('DELETE FROM address_book_subscriptions WHERE group_id=' . $this->getPrimaryKey());
      }
      else if ((isset($oldDirtyFlags['publicGids']) || isset($oldDirtyFlags['publicUids'])) && ($subscriptions =& $this->getSubscribedToBy())) {
        $removeIds = array();
        $keys = array_keys($subscriptions);
        foreach($keys as $key) {
          if (!$this->canSubscribe($subscriptions[$key]->getUid())) {
            $removeIds[] = $subscriptions[$key]->getPrimaryKey();
          }
        }
        if (count($removeIds)) {
          $db->execute('DELETE FROM address_book_subscriptions WHERE group_id=' . $this->getPrimaryKey() . ' AND address_book_id IN (' . implode(',', $removeIds) . ')');
        }
      }
      ]]></introduction>
      <introduction key="searchContacts" class="vo" type="method" value="&amp;searchContacts($search, $attr, $limit, $offset)"><![CDATA[
      // searches the contacts in this contact group and returns the matches 
      // ordered by the match score
      return MyContactsManager::_searchContacts(NULL, $this->getGroupId(), $search, $attr, $limit, $offset);
      ]]></introduction>
    </aop>
    <attribute key="groupId" sequence="1">
      <view key="output" extends="input-hidden" />
    </attribute>
    <attribute key="addressBook" type="AddressBook" />
    <attribute key="gid" type="int" />
    <attribute key="name" depends="required" max-length="64" />
    <attribute key="contacts" cardinality="0..*" table="group_contacts" type="Contact" />
    <attribute key="public" default="FALSE" type="boolean" />
    <attribute key="publicGids" cardinality="0..*" max-length="255" />
    <attribute key="publicUids" cardinality="0..*" max-length="255" />
    <attribute key="publicReadOnly" default="TRUE" type="boolean" />
    <attribute key="subscribedToBy" cardinality="0..*" table="address_book_subscriptions" type="AddressBook" />
    
    <view key="input" template="plugins/accessories/contact-group-form.tpl" />
  </entity>
  
  <entity key="ContactImId" primary-key="imId">
    <aop>
      <advice key="updateSearchIndex"><![CDATA[
      if (($updated || $inserted) && (isset($oldDirtyFlags['id']))) { ContactVO::rebuildSearchIndex($record->getContactId()); }
      ]]></advice>
      
      <aspect key="updateSearchIndexInsert" advice="updateSearchIndex" pointcut="dao.insert" when="after" />
      <aspect key="updateSearchIndexUpdate" advice="updateSearchIndex" pointcut="dao.update" when="after" />
      
      <introduction key="getContact" class="vo" type="method" value="&amp;getContact()"><![CDATA[
      // returns a reference to the contact associated with this im id
      $contact = NULL;
      if ($this->_contactId) {
        $dao =& SRA_DaoFactory::getDao('Contact');
        $contact =& $dao->findByPk($this->_contactId);
      }
      return $contact;
      ]]></introduction>
      <introduction key="getProtocolName" class="vo" type="method" value="getProtocolName()"><![CDATA[
      // returns the protocol name for this im
      $rb =& SRA_ResourceBundle::getBundle('etc/plugins/accessories/l10n/im-protocols');
      return $rb->getString($this->getProtocol());
      ]]></introduction>
    </aop>
    <attribute key="imId" sequence="1" />
    <attribute key="contactId" type="int" />
    <attribute key="id" depends="required" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="protocol" depends="option required" max-length="32">
      <var key="resources" value="etc/plugins/accessories/l10n/im-protocols" />
      <view key="field" extends="input-select">
        <param id="class" type="select-attrs" value="myContactCardField" />
      </view>
      <view key="input" extends="input-ci">
        <param id="labelClass" value="editModeSelectorInline" />
      </view>
      <view key="output" extends="option" />
    </attribute>
    <attribute key="type" default="'home'" depends="required" max-length="64" resource="text.type" xml-use-attribute="1">
      <var key="resources" value="etc/plugins/accessories/l10n/contact-attr-types" />
      <view key="field" extends="input-select-other">
        <param id="class" type="select-attrs" value="myContactCardField" />
        <param id="otherOptionCallback" value="MyContacts._currentInstance.updateTypeLabel" />
      </view>
      <view key="input" extends="input-ci">
        <param id="labelClass" value="editModeSelector" />
      </view>
      <view key="output" extends="option" />
    </attribute>
    
    <view key="input" template="plugins/accessories/contact-im-form.tpl" />
  </entity>
  
  <entity key="ContactName" primary-key="nameId">
    <aop>
      <advice key="updateSearchIndex"><![CDATA[
      if (($updated || $inserted) && (isset($oldDirtyFlags['companyName']) || isset($oldDirtyFlags['department']) || isset($oldDirtyFlags['first']) || isset($oldDirtyFlags['jobTitle']) || isset($oldDirtyFlags['last']) || isset($oldDirtyFlags['maiden']) || isset($oldDirtyFlags['middle']) || isset($oldDirtyFlags['nameNote']) || isset($oldDirtyFlags['nickname']) || isset($oldDirtyFlags['phoneticFirst']) || isset($oldDirtyFlags['phoneticLast']) || isset($oldDirtyFlags['phoneticMiddle']))) { ContactVO::rebuildSearchIndex($record->getContactId()); }
      ]]></advice>
      
      <aspect key="updateSearchIndexInsert" advice="updateSearchIndex" pointcut="dao.insert" when="after" />
      <aspect key="updateSearchIndexUpdate" advice="updateSearchIndex" pointcut="dao.update" when="after" />
      
      <introduction key="getContact" class="vo" type="method" value="&amp;getContact()"><![CDATA[
      // returns a reference to the contact associated with this name
      $contact = NULL;
      if ($this->_contactId) {
        $dao =& SRA_DaoFactory::getDao('Contact');
        $contact =& $dao->findByPk($this->_contactId);
      }
      return $contact;
      ]]></introduction>
      <introduction key="getNameLabel" class="vo" type="method" value="getNameLabel()"><![CDATA[
      // returns the correct label to use for this name depending on whether 
      // it is a person or a company
      return $this->isCompany() || $this->isOccupation() ? $this->getCompanyName() : $this->getFullName();
      ]]></introduction>
      <introduction key="getFullName" class="vo" type="method" value="getFullName()"><![CDATA[
      // returns the full name to use for this contact
      global $user;
      $middle = $this->getMiddle() && $user && $user->displayContactField('middle') ? ' ' . $this->getMiddle() : '';
      return $user && $user->getAttribute('myContactsPreferences_nameFormat') == 'last_first' ? $this->getLast() . ', ' . $this->getFirst() . $middle : $this->getFirst() . $middle . ' ' . $this->getLast();
      ]]></introduction>
      <introduction key="getPhoneticFullName" class="vo" type="method" value="getPhoneticFullName()"><![CDATA[
      // returns the phonetic full name (if applicable) to use for this contact
      global $user;
      $middle = $this->getPhoneticMiddle() && $user && $user->displayContactField('middle') ? ' ' . $this->getPhoneticMiddle() : '';
      $name = $user && $user->getAttribute('myContactsPreferences_nameFormat') == 'last_first' ? $this->getPhoneticLast() . ', ' . $this->getPhoneticFirst() . $middle : $this->getPhoneticFirst() . $middle . ' ' . $this->getPhoneticLast();
      return trim($name) ? $name : NULL;
      ]]></introduction>
    </aop>
    <attribute key="nameId" sequence="1">
      <view key="output" extends="input-hidden" />
    </attribute>
    <attribute key="company" default="FALSE" type="boolean">
      <view key="input" extends="input-checkbox">
        <param id="onchange" type="input-attrs" value="MyContacts._currentInstance.toggleNameCompany(this);" />
      </view>
    </attribute>
    <attribute key="companyName" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="contactId" type="int" />
    <attribute key="dateEnd" type="date">
      <view key="field" extends="input-date-chooser-ci">
        <param id="class" type="input-attrs" value="myContactCardDateField" />
      </view>
      <view key="input" extends="input-ci" />
      <view key="output" extends="date" />
    </attribute>
    <attribute key="dateStart" type="date">
      <view key="field" extends="input-date-chooser-ci">
        <param id="class" type="input-attrs" value="myContactCardDateField" />
      </view>
      <view key="input" extends="input-ci" />
      <view key="output" extends="date" />
    </attribute>
    <attribute key="department" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="first" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="jobTitle" max-length="255">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="label" max-length="64">
      <view key="input" extends="input-text-ci">
        <param id="labelClass" value="editMode" />
      </view>
    </attribute>
    <attribute key="last" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="maiden" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="middle" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="nameNote">
      <view key="input" extends="input-textarea-ci" />
    </attribute>
    <attribute key="nickname" global-name="nickname" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="occupation" default="FALSE" type="boolean">
      <view key="input" extends="input-checkbox">
        <param id="onchange" type="input-attrs" value="MyContacts._currentInstance.toggleNameCompany(this);" />
      </view>
    </attribute>
    <attribute key="phoneticFirst" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="phoneticLast" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="phoneticMiddle" max-length="128">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="prefix" max-length="32">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="suffix" max-length="32">
      <view key="input" extends="input-text-ci" />
    </attribute>
    
    <view key="fields" template="plugins/accessories/contact-name-form-fields.tpl" />
    <view key="input" template="plugins/accessories/contact-name-form.tpl" />
  </entity>
  
  <entity key="ContactPhone" primary-key="phoneId">
    <aop>
      <advice key="updateSearchIndex"><![CDATA[
      if (($updated || $inserted) && (isset($oldDirtyFlags['number']))) { ContactVO::rebuildSearchIndex($record->getContactId()); }
      ]]></advice>
      
      <aspect key="trimNumber" pointcut="vo.setNumber"><![CDATA[
      // trim the # provided
      if (isset($number)) { 
        $number = trim($number);
        if (!$number) { $number = NULL; }
      }
      ]]></aspect>
      <aspect key="updateSearchIndexInsert" advice="updateSearchIndex" pointcut="dao.insert" when="after" />
      <aspect key="updateSearchIndexUpdate" advice="updateSearchIndex" pointcut="dao.update" when="after" />
      
      <introduction key="getContact" class="vo" type="method" value="&amp;getContact()"><![CDATA[
      // returns a reference to the contact associated with this phone
      $contact = NULL;
      if ($this->_contactId) {
        $dao =& SRA_DaoFactory::getDao('Contact');
        $contact =& $dao->findByPk($this->_contactId);
      }
      return $contact;
      ]]></introduction>
      <introduction key="getFormattedNumber" class="vo" type="method" value="getFormattedNumber()"><![CDATA[
      // formats the phone # according to the user's preferences
      global $user;
      if ($this->_number && $user && $user->getAttribute('myContactsPreferences_formatPhoneNumbers') && ($format = $user->getAttribute('myContactsPreferences_phoneFormat'))) {
        $newNumber = '';
        $numberCounter = 0;
        $numbersIdx = 0;
        
        preg_match_all('/[0-9]/', $this->_number, $matches, PREG_OFFSET_CAPTURE);
        $numbers = $matches[0];
        $numNumbers = count($numbers);
        
        preg_match_all('/#/', $format, $matches);
        $numFormatNumbers = count($matches[0]);
        
        for($i=0; $i<strlen($format); $i++) {
          if ($numNumbers >= $numFormatNumbers || $numberCounter >= ($numFormatNumbers - $numNumbers)) {
            if (substr($format, $i, 1) == '#') {
              $newNumber .= $numbers[$numbersIdx][0];
              $numbersIdx++;
            }
            else {
              $newNumber .= substr($format, $i, 1);
            }
          }
          if (substr($format, $i, 1) == '#') {
            $numberCounter++;
          }
        }
        // add suffix
        if (isset($numbers[$numbersIdx]) && $numbers[$numbersIdx][1] < (strlen($this->_number) - 1)) {
          $newNumber .= substr($this->_number, $numbers[$numbersIdx][1]);
        }
        
        // remove leading whitespace/invalid characters
        $start = 0;
        for($i=0; $i<strlen($newNumber); $i++) {
          if (preg_match('/[a-z|A-Z|(|0-9]/', substr($newNumber, $i, 1))) { break; }
          $start++;
        }
        return substr($newNumber, $start);
      }
      else {
        return NULL;
      }
      ]]></introduction>
    </aop>
    <attribute key="phoneId" sequence="1">
      <view key="output" extends="input-hidden" />
    </attribute>
    <attribute key="contactId" type="int" />
    <attribute key="number" depends="required" max-length="32">
      <view key="input" extends="input-text-ci" />
    </attribute>
    <attribute key="type" default="'home'" depends="required" max-length="64" xml-use-attribute="1">
      <var key="resources" value="etc/plugins/accessories/l10n/phone-types" />
      <view key="field" extends="input-select-other">
        <param id="class" type="select-attrs" value="myContactCardField" />
        <param id="otherOptionCallback" value="MyContacts._currentInstance.updateTypeLabel" />
      </view>
      <view key="input" extends="input-ci">
        <param id="labelClass" value="editModeSelector" />
      </view>
      <view key="output" extends="option" />
    </attribute>
    
    <view key="input" template="plugins/accessories/contact-phone-form.tpl" />
  </entity>
  
  <entity key="ContactRelation" primary-key="relationId">
    <aop>
      <introduction key="canViewTarget" class="vo" type="method" value="canViewTarget()"><![CDATA[
      // returns TRUE if the current user can view the target contact defined by
      // this relation 
      return $this->getTarget() && ContactVO::canView($this->getTarget());
      ]]></introduction>
      <introduction key="getContact" class="vo" type="method" value="&amp;getContact()"><![CDATA[
      // returns a reference to the contact associated with this relation
      $contact = NULL;
      if ($this->_source) {
        $dao =& SRA_DaoFactory::getDao('Contact');
        $contact =& $dao->findByPk($this->_source);
      }
      return $contact;
      ]]></introduction>
      <introduction key="getSourceName" class="vo" type="method" value="getSourceName()"><![CDATA[
      // returns the name for the relation source
      return $this->getSource() && ($dao =& SRA_DaoFactory::getDao('Contact')) && ($contact =& $dao->findByPk($this->getSource())) ? $contact->getContactLabel() : NULL;
      ]]></introduction>
      <introduction key="getTargetName" class="vo" type="method" value="getTargetName()"><![CDATA[
      // returns the name for the relation target
      return $this->getTarget() && ($dao =& SRA_DaoFactory::getDao('Contact')) && ($contact =& $dao->findByPk($this->getTarget())) ? $contact->getContactLabel() : NULL;
      ]]></introduction>
    </aop>
    <attribute key="relationId" sequence="1">
      <view key="output" extends="input-hidden" />
    </attribute>
    <attribute key="dateEnd" type="date">
      <view key="field" extends="input-date-chooser-ci">
        <param id="class" type="input-attrs" value="myContactCardDateField" />
      </view>
      <view key="input" extends="input-ci" />
      <view key="output" extends="date" />
    </attribute>
    <attribute key="dateStart" type="date">
      <view key="field" extends="input-date-chooser-ci">
        <param id="class" type="input-attrs" value="myContactCardDateField" />
      </view>
      <view key="input" extends="input-ci" />
      <view key="output" extends="date" />
    </attribute>
    <attribute key="source" type="int" />
    <attribute key="target" depends="required" type="int">
      <view key="field" template="plugins/accessories/contact-selector.tpl">
        <param id="class" type="input-attrs" value="inputField" />
        <param id="display" value="{$getTargetName}" />
      </view>
      <view key="input" extends="input-ci">
        <param id="noValueResource" value="text.notSpecified" />
      </view>
      <view key="output" extends="text">
        <param id="value" type="formatStr" value="{$getTargetName}" />
      </view>
    </attribute>
    <attribute key="type" depends="required" max-length="32" xml-use-attribute="1">
      <var key="resources" value="etc/plugins/accessories/l10n/relations" />
      <view key="field" extends="input-select-other">
        <param id="class" type="select-attrs" value="myContactCardField" />
        <param id="otherOptionCallback" value="MyContacts._currentInstance.updateTypeLabel" />
      </view>
      <view key="input" extends="input-ci">
        <param id="labelClass" value="editModeSelector" />
      </view>
      <view key="output" extends="option" />
    </attribute>
    
    <view key="input" template="plugins/accessories/contact-relation-form.tpl" />
  </entity>
  
  <entity key="ContactUrl" primary-key="urlId">
    <aop>
      <advice key="updateSearchIndex"><![CDATA[
      if (($updated || $inserted) && (isset($oldDirtyFlags['url']))) { ContactVO::rebuildSearchIndex($record->getContactId()); }
      ]]></advice>
      
      <aspect key="updateSearchIndexInsert" advice="updateSearchIndex" pointcut="dao.insert" when="after" />
      <aspect key="updateSearchIndexUpdate" advice="updateSearchIndex" pointcut="dao.update" when="after" />
      
      <introduction key="getContact" class="vo" type="method" value="&amp;getContact()"><![CDATA[
      // returns a reference to the contact associated with this url
      $contact = NULL;
      if ($this->_contactId) {
        $dao =& SRA_DaoFactory::getDao('Contact');
        $contact =& $dao->findByPk($this->_contactId);
      }
      return $contact;
      ]]></introduction>
    </aop>
    <attribute key="urlId" sequence="1">
      <view key="output" extends="input-hidden" />
    </attribute>
    <attribute key="contactId" type="int" />
    <attribute key="type" default="homePage" depends="required" max-length="64" resource="text.type" xml-use-attribute="1">
      <var key="resources" value="etc/plugins/accessories/l10n/url-types" />
      <view key="field" extends="input-select-other">
        <param id="class" type="select-attrs" value="myContactCardField" />
        <param id="otherOptionCallback" value="MyContacts._currentInstance.updateTypeLabel" />
      </view>
      <view key="input" extends="input-ci">
        <param id="labelClass" value="editModeSelector" />
      </view>
      <view key="output" extends="option" />
    </attribute>
    <attribute key="url" depends="uri required" max-length="255">
      <view key="input" extends="input-text-ci" />
    </attribute>
    
    <view key="input" template="plugins/accessories/contact-url-form.tpl" />
  </entity>
  
  <entity key="MyContactsPreferences" primary-key="preferencesId">
    <ajax-service key="getMyContactsPreferencesForm" view="myContactsPreferences" />
    <ajax-service key="updateMyContactsPreferences" retrieve="0" update="1" />
    <aop>
      <aspect key="phoneFormatOptions" pointcut="vo.getOptionsMap"><![CDATA[
      // return phone format options
      if ('phoneFormat' == $attr) {
        if (SRA_ResourceBundle::isValid($rb =& SRA_ResourceBundle::getBundle('etc/plugins/accessories/l10n/contact-phone-formats'))) {
          $baseOptions = $rb->getData();
          $options = array();
          $keys = array_keys($baseOptions);
          foreach($keys as $key) {
            $options[str_replace('n', '#', $key)] = $baseOptions[$key];
          }
        }
      }
      ]]></aspect>
      <aspect key="validatePermissions" pointcut="vo.validate" when="after"><![CDATA[
      // does user have access to update these permissions
      if (!$this->validateErrors && $this->recordExists) {
        global $user;
        if (!$user || ($user->getUid() != $this->getUid() && !$user->isChild($this->getUid()))) {
          $this->validateErrors[] = $rb->getString('MyContactsPreferences.error.permissions');
        }
      }
      ]]></aspect>
      
      <introduction key="displayContactField" class="vo" type="method" value="displayContactField($field)"><![CDATA[
      // returns TRUE if the contact field specified should be displayed for 
      // these preferences
      global $_myContactsDisplayFields;
      return in_array($field, $_myContactsDisplayFields ? $_myContactsDisplayFields : $this->getFields());
      ]]></introduction>
    </aop>
    <attribute key="preferencesId" sequence="1">
      <view key="output" extends="input-hidden" />
    </attribute>
    <attribute key="fields" cardinality="0..*" default="array('jobTitle', 'department', 'phones', 'emails', 'addresses', 'groups')" depends="options">
      <var key="resources" value="etc/plugins/accessories/l10n/contact-fields" />
      <view key="input" extends="input-checkboxes" />
    </attribute>
    <attribute key="formatPhoneNumbers" default="TRUE" type="boolean">
      <view key="input" extends="input-select-bool-required" />
    </attribute>
    <attribute key="nameFormat" default="last_first" depends="options" max-length="16">
      <var key="resources" value="etc/plugins/accessories/l10n/mycontacts-name-formats" />
      <view key="input" extends="input-radio" />
    </attribute>
    <attribute key="phoneFormat" default="'#-###-###-####'" depends="required" max-length="32">
      <view key="input" extends="input-select-other">
        <param id="otherOptionLabel" value="MyContactsPreferences.phoneFormat.otherLabel" />
        <param id="otherOptionPrompt" value="MyContactsPreferences.phoneFormat.otherPrompt" />
      </view>
    </attribute>
    <attribute key="sortBy" default="last" depends="option" max-length="16">
      <var key="resources" value="etc/plugins/accessories/l10n/mycontacts-sort-by" />
      <view key="input" extends="input-radio" />
    </attribute>
    <attribute key="uid" depends="required" type="int" />
		<view key="myContactsPreferences" template="model/sra-grid.tpl">
      <param id="header"                                value="{$getString(MyContacts.preferences)}" />
      <param id="nameFormat"         type="col-set0-0"  value="input" />
      <param id="sortBy"             type="col-set0-0"  value="input" />
      <param id="fields"             type="col-set0-0"  value="input" />
      <param id="formatPhoneNumbers" type="col-set0-0"  value="input" />
      <param id="phoneFormat"        type="col-set0-0"  value="input" />
      <param id="preferencesId"      type="pre-attrs"   value="input" />
      <param id="class"              type="table-attrs" value="preferencesTable" />
		</view>
  </entity>
  
  <entity key="OsGroup">
    <aop>
      <aspect key="createContactGroup" pointcut="dao.insert" when="after"><![CDATA[
      // create a corresponding contact group for this user group
      if ($inserted) { $record->_getContactGroup(); }
      ]]></aspect>
      <aspect key="removeFromContactGroups" pointcut="dao.delete" when="after"><![CDATA[
      // create a corresponding contact group for this user group
      if ($deleted) { $record->_removeFromContactGroups(); }
      ]]></aspect>
      <aspect key="syncContactGroup" pointcut="dao.update" when="after"><![CDATA[
      // synchronizes the contact group for this user group
      if ($updated && (!$record->hasContactGroup() || isset($oldDirtyFlags['ownerUid']) || isset($oldDirtyFlags['name']) || isset($oldDirtyFlags['members']))) { $record->_syncContactGroup(); }
      if ($updated && (isset($oldDirtyFlags['members']))) { $record->_syncContactGroupSubscriptions(); }
      ]]></aspect>
      
      <introduction key="getContactGroups" class="vo" type="method" value="&amp;getContactGroups()"><![CDATA[
      // returns all of the contact groups with permissions associated to this 
      // user group indexed by group id
      if (!isset($this->_contactGroups)) {
        $this->_contactGroups = array();
        if ($groupIds =& $this->getContactGroupIds()) {
          $dao =& SRA_DaoFactory::getDao('ContactGroup');
          foreach($groupIds as $groupId) {
            $this->_contactGroups[$groupId] =& $dao->findByPk($groupId);
          }
        }
      }
      return $this->_contactGroups;
      ]]></introduction>
      <introduction key="getContactGroupIds" class="vo" type="method" value="&amp;getContactGroupIds()"><![CDATA[
      // returns all of the ids of all of the contact groups with permissions 
      // associated to this user group
      if (!isset($this->_contactGroupIds)) {
        $this->_contactGroupIds = array();
        $db =& SRA_Controller::getAppDb();
        $results =& $db->fetch('SELECT group_id, public_gid FROM contact_group WHERE public_gid like ' . $db->convertText('%' . $this->getGid() . '%'), array(SRA_DATA_TYPE_INT, SRA_DATA_TYPE_TEXT));
        while($row =& $results->next()) {
          if (in_array($this->getGid() , explode(SRA_AGGREGATE_CARDINALITY_DELIM, $row[1]))) {
            $this->_contactGroupIds[] = $row[0];
          }
        }
      }
      return $this->_contactGroupIds;
      ]]></introduction>
      <introduction key="hasContactGroup" class="vo" type="method" value="hasContactGroup()"><![CDATA[
      // returns TRUE if this user group current has a contact group
      return SRA_Database::getQueryValue(SRA_Controller::getAppDb(), 'SELECT count(*) FROM contact_group WHERE gid=' . $this->getGid(), array(SRA_DATA_TYPE_INT));
      ]]></introduction>
      <introduction key="_getContactGroup" class="vo" type="method" value="&amp;_getContactGroup()"><![CDATA[
      // creates a corresponding contact group for this user group
      if (!$this->getContactGroup()) {
        $dao =& SRA_DaoFactory::getDao('ContactGroup');
        $group =& $dao->newInstance(array('gid' => $this->getGid(), 'name' => $this->getName(), 'public' => TRUE, 'publicGids' => array($this->getGid()), 'publicReadOnly' => TRUE, 'publicUids' => array($this->getOwnerUid())));
        $dao->insert($group);
        $this->setContactGroup($group, FALSE);
        $this->_syncContactGroup();
      }
      return $this->_contactGroup;
      ]]></introduction>
      <introduction key="_removeFromContactGroups" class="vo" type="method" value="_removeFromContactGroups()"><![CDATA[
      // removes this group from any contact groups with permissions associated 
      // with it
      if ($groups =& $this->getContactGroups()) {
        $keys = array_keys($groups);
        foreach($keys as $key) {
          $groups[$key]->removePublicGids($this->getGid());
          $groups[$key]->update();
        }
      }
      ]]></introduction>
      <introduction key="_syncContactGroup" class="vo" type="method" value="&amp;_syncContactGroup()"><![CDATA[
      // synchronizes the permissions and members of this user group's contact 
      // group
      $group =& $this->_getContactGroup();
      
      // set group name
      $group->setName($this->getName());
      
      // set group contacts
      $cids = array();
      $db =& SRA_Controller::getAppDb();
      if ($uids = array_keys($this->getUserHash())) {
        $results =& $db->fetch('SELECT contact_id FROM contact WHERE uid IN (' . implode(',', $uids) . ')', array(SRA_DATA_TYPE_INT));
        while($row =& $results->next()) {
          $cids[$row[0]] = TRUE;
        }
      }
      $cids = array_keys($cids);
      $group->setContacts($cids);
      
      // set group user access permissions
      $group->setPublicUids(array($this->getOwnerUid()));
      
      // update group
      $group->update();
      
      // remove any subscriptions that are not valid
      if (!$uids) {
        $uids = array($this->getOwnerUid());
      }
      else if (!in_array($this->getOwnerUid(), $uids)) {
        $uids[] = $this->getOwnerUid();
      }
      
      ]]></introduction>
      <introduction key="_syncContactGroupSubscriptions" class="vo" type="method" value="&amp;_syncContactGroupSubscriptions()"><![CDATA[
      // removes any subscriptions to any public contact groups with permissions 
      // based on this user group
      if ($this->getContactGroupIds()) {
        $uids = array_keys($this->getUserHash());
        if (!$uids) {
          $uids = array($this->getOwnerUid());
        }
        else if (!in_array($this->getOwnerUid(), $uids)) {
          $uids[] = $this->getOwnerUid();
        }
        
        $db =& SRA_Controller::getAppDb();
        $results =& $db->fetch('SELECT a.address_book_id, a.uid, g.public_uid, g.group_id FROM address_book a, address_book_subscriptions s, contact_group g ' . 
                               'WHERE g.group_id IN(' . implode(',', $this->getContactGroupIds()) . ') AND g.group_id=s.group_id AND a.address_book_id=s.address_book_id', 
                               array(SRA_DATA_TYPE_INT, SRA_DATA_TYPE_INT, SRA_DATA_TYPE_TEXT, SRA_DATA_TYPE_INT));
        while($row =& $results->next()) {
          $publicUids = $row[2] ? explode(SRA_AGGREGATE_CARDINALITY_DELIM, $row[2]) : array();
          if (!in_array($row[1], $uids) && !in_array($row[1], $publicUids)) {
            $db->execute('DELETE FROM address_book_subscriptions WHERE address_book_id=' . $row[0] . ' AND group_id=' . $row[3]);
          }
        }
      }
      ]]></introduction>
    </aop>
    <attribute key="contactGroup" on-delete-cascade="1" table-pk-column="gid" type="ContactGroup" />
  </entity>
  
  <entity key="OsUser">
    <aop>
      <aspect key="getAddressBook" pointcut="vo.getAddressBook" when="after"><![CDATA[
      // create a new address book and contact if one does not already exist
      static $_userAddressBooks = array();
      if (!isset($this->_addressBook) && $this->recordExists) {
        if (isset($_userAddressBooks[$this->getUid()])) { 
          $this->_addressBook =& $_userAddressBooks[$this->getUid()];
        }
        else {
          $addressBook = new AddressBookVO(array('uid' => $this->getUid()));
          $this->_addressBook =& $addressBook;
          $_userAddressBooks[$this->getUid()] =& $addressBook;
          $myContact = new ContactVO(array('uid' => $this->getUid()));
          $pieces = explode(' ', $this->getName());
          $myContact->setLast($pieces[count($pieces) - 1]);
          if (count($pieces) > 1) {
            $first = '';
            for($i=0; $i<count($pieces)-1; $i++) {
              $first .= $i>0 ? ' ' : '';
              $first .= $pieces[$i];
            }
            $myContact->setFirst($first);
          }
          if ($this->getEmail()) {
            $myContact->addEmails(new ContactEmailVO(array('email' => $this->getEmail(), 'type' => 'work')));
          }
          if (SRA_FileAttribute::isValid($this->getPicture())) {
            $myContact->setPicture($this->getPicture());;
          }
          $addressBook->addContacts($myContact);
          $addressBook->insert();
        }
      }
      ]]></aspect>
      <aspect key="getMyContactsPreferences" pointcut="vo.getMyContactsPreferences"><![CDATA[
      // create new preferences if they do not already exist
      if (!isset($this->_myContactsPreferences) && $this->getUid() && !SRA_Database::getQueryValue(SRA_Controller::getAppDb(), 'SELECT preferences_id FROM my_contacts_preferences WHERE uid=' . $this->getUid())) {
        $dao =& SRA_DaoFactory::getDao('MyContactsPreferences');
        $preferences =& $dao->newInstance(array('uid' => $this->getUid()));
        $dao->insert($preferences);
        $this->setMyContactsPreferences($preferences, FALSE);
      }
      ]]></aspect>
      
      <introduction key="displayContactField" class="vo" type="method" value="displayContactField($field)"><![CDATA[
      // returns TRUE if the contact field specified should be displayed for this
      // user
      $preferences =& $this->getMyContactsPreferences();
      return $preferences->displayContactField($field);
      ]]></introduction>
      <introduction key="getMyCard" class="vo" type="method" value="&amp;getMyCard()"><![CDATA[
      $addressBook =& $this->getAddressBook();
      return $addressBook->getUserContact();
      ]]></introduction>
      <introduction key="getMyCardId" class="vo" type="method" value="getMyCardId($uid=NULL)"><![CDATA[
      // this method is optimized to return the contactId of the card belonging 
      // to this user (or to the user identified by $uid)
      $db =& SRA_Controller::getAppDb();
      $uid = $uid ? $uid : $this->getUid();
      if ($uid && $addressBookId = SRA_Database::getQueryValue($db, 'SELECT address_book_id FROM address_book WHERE uid=' . $uid, SRA_DATA_TYPE_INT)) {
        return SRA_Database::getQueryValue($db, 'SELECT contact_id FROM contact WHERE uid=' . $uid . ' AND address_book_id=' . $addressBookId, SRA_DATA_TYPE_INT);
      }
      else {
        $dao =& SRA_DaoFactory::getDao('OsUser');
        if (OsUserVO::isValid($user =& $dao->findByPk($uid))) {
          $card =& $user->getMyCard();
          return $card->getContactId();
        }
      }
      ]]></introduction>
    </aop>
    <attribute key="addressBook" on-delete-cascade="1" table-pk-column="uid" type="AddressBook" />
    <attribute key="myContactsPreferences" on-delete-cascade="1" table-pk-column="uid" type="MyContactsPreferences" />
  </entity>
  
  
  <global-ajax-service key="myContactsAssociateImbedded" identifier="plugins/accessories/MyContactsManager::associateImbeddedContact" type="method" />
  <global-ajax-service key="myContactsGetAddressFieldOptions" identifier="util/l10n/SRA_AddressFormat::getFieldOptions" type="method" />
  <global-ajax-service key="myContactsGetAvailableSubscriptions" identifier="plugins/accessories/MyContactsManager::getAvailableSubscriptions" type="method" />
  <global-ajax-service key="myContactsGetContactAttributeView" identifier="plugins/accessories/MyContactsManager::getContactAttributeView" type="method" />
  <global-ajax-service key="myContactsGetContactView" identifier="plugins/accessories/MyContactsManager::getContactView" type="method" />
  <global-ajax-service key="myContactsPrintContact" identifier="plugins/accessories/MyContactsManager::printContact" raw="1" type="method" />
  <global-ajax-service key="myContactsSearchContacts" identifier="plugins/accessories/MyContactsManager::searchContacts" type="method" />
  
  
  <!-- performance related indexes -->
  <index key="addressBookUidIdx" columns="uid" modifier="unique" table="address_book" />
  
  <index key="addressBookPreferencesUidIdx" columns="uid" modifier="unique" table="address_book_preferences" />
  
  <index key="contactAddressBookIdx" columns="address_book_id" table="contact" />
  <index key="contactAddressBookContactIdIdx" columns="address_book_id, contact_id" table="contact" />
  <index key="contactAddressBookUidIdx" columns="address_book_id, uid" table="contact" />
  <index key="contactCompanyNameIdx" columns="company_name" table="contact" />
  <index key="contactFirstIdx" columns="first" table="contact" />
  <index key="contactImbeddedIdx" columns="imbedded" table="contact" />
  <index key="contactLastIdx" columns="last" table="contact" />
  <index key="contactNameIdx" columns="first, last" table="contact" />
  <index key="contactUidIdx" columns="uid" modifier="unique" table="contact" />
  
  <index key="contactGroupGidIdx" columns="gid" table="contact_group" />
  <index key="contactGroupNameIdx" columns="name" table="contact_group" />
  <index key="contactGroupPublicGidIdx" columns="public_gid" table="contact_group" />
  
  <index key="groupContactsIdx" columns="contact_id, group_id" table="group_contacts" />
  
  <index key="contactSearchIdx" columns="search_index" modifier="fulltext" table="contact_search_index" />
</entity-model>
